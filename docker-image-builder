#!/bin/bash
# Facade script for working with Git-based Docker repositories.
#
# (C) 2014 INAETICS, <www.inaetics.org> - Apache License v2.

# Script return values
readonly EOK=0
readonly EINVALID_ARGS=1
readonly EMISSING_COMMAND=2
readonly ENO_DOCKER_REPO=3
readonly EETCD_UNREACHABLE=4
readonly EREPO_CLONE_FAILED=5
readonly EBUILD_FAILURE=6
readonly EPUBLISH_FAILED=7
readonly EUNKNOWN_IMAGE=8
# Local constants
readonly builder_root="/tmp/image-builder"
readonly etcd_ns="/inaetics/docker-image-builder"

# External "libraries"
source "$(dirname $0)/lib/docker.sh"
source "$(dirname $0)/lib/etcdctl.sh"

_log() {
    echo $@ >&2
}

_show_usage() {
    echo "Usage: $(basename $0) COMMAND [arg...]

Commands:
  build REPO_NAME GIT_REPO_URL
     builds a new or updates an existing Docker image, pulling the repository from
     the given Git repository URL and tagging it with the given REPO_NAME;
  list
     shows a list of all build images.
  update
     checks all previously build images and rebuild them if necessary.
"
    exit $EINVALID_ARGS
}

# Assume we're running a Docker repository locally, can be overridden...
docker_repos=${DOCKER_REPOSITORIES:-"localhost:5000"}

# Fetch the arguments & check semantics
command=$1

if [ "$command" == "build" ]; then
    # Needs two additional arguments
    img_name=$2
    git_repo_url=$3

    if [ -z $img_name ] || [ -z $git_repo_url ]; then
        _show_usage
    fi
elif [ "$command" != "list" ] && [ "$command" != "update" ]; then
    _show_usage
fi

# We depend on Etcd, Git and Docker, so lets verify we can use those...
missing=0
for cmd in etcdctl git docker; do
    if ! hash "$cmd" >/dev/null 2>&1; then
        _log "Command $cmd not found in PATH! Cannot run $(basename $0)!"
        ((missing++))
    fi
done
# Do not try to continue with this...
if ((missing > 0)); then
    exit $EMISSING_COMMAND
fi

# Try to invoke etcdctl, to see we can contact the Etcd node (or cluster)...
etcdctl ls >/dev/null 2>&1
if [ $? -ne 0 ]; then
    _log "Unable to access Etcd, is it not running?!"
    exit $EETCD_UNREACHABLE
fi

# Returns the image ID of an earlier build Docker image (from Etcd)
#   args: NS - the Etcd namespace to look for build images;
#         IMG_NAME - the name of the image to fetch the ID for.
#   returns: the full image ID.
_get_build_image_id () {
    local ns=$1
    local img_name=$2

    etcd/value "$ns/$img_name/dockerId"
}

# Returns the current revision of a Git branch.
#   args: BRANCH - the name of the branch to get the revision for.
#   returns: the revision (or commit) hash.
_get_git_rev () {
    local branch=$1

    git log --pretty=oneline -1 $branch 2>/dev/null | awk '{print $1}'
}

# Returns all build image names from Etcd.
_get_build_image_names () {
    local ns=$1

    etcdctl ls "$ns" --recursive | grep gitRev | sed 's/\/gitRev$//'
}

# Provides a list of all images that were build.
#   args: NS - the Etcd namespace to look for build images
#   returns: <img name> <git URL> <docker ID>
_list_build_images () {
    local ns=$1
    local imgs=($(_get_build_image_names $ns))
    printf "%-25s %-12s %-12s %s\n" "REPOSITORY NAME" "IMAGE ID" "GIT REV" "GIT URL"
    for img in ${imgs[@]}; do
        local gitRev=$(etcd/value "$img/gitRev" | tr -d "\"")
        local gitUrl=$(etcd/value "$img/gitRepo" | tr -d "\"")
        local dockerId=$(etcd/value "$img/dockerId" | tr -d "\"")
        printf "%-25s %.12s %.12s %s\n" ${img/$ns\//} $dockerId $gitRev $gitUrl
    done
}

# Native implementation of URLEncode, taken from <https://gist.github.com/cdown/1163649>.
#   arg: URL - the URL/text to URL encode.
#   returns: URL encoded text.
_urlencode () {
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
            case $c in
                [a-zA-Z0-9.~_-]) printf "$c" ;;
                *) printf '%%%02X' "'$c"
            esac
    done
}

# Does a search-and-replace for the '##APT_PROXY' placeholder
#   args: FILE - the file to do the search-and-replace on.
#   returns: nothing
_replace_apt_cacher () {
    local file=$1

    local services=($(etcd/values "inaetics/apt-cacher-service"))
    if [ ${#services[@]} -eq 0 ]; then
         _log "Cannot replace APT_CACHER macro: no services available!"
     else
         _log "Injecting APT CACHER service: ${services[0]}"
         local value="RUN echo \"Acquire::http::Proxy \\\\\"http://${services[0]}\\\\\";\" \
            >/etc/apt/apt.conf.d/01proxy"
         sed -i "/##APT_PROXY/ c\\$value" $file
    fi
}

# Does a search-and-replace for the '##JDK_LOCATION' placeholder
#   args: FILE - the file to do the search-and-replace on.
#   returns: nothing
_replace_jdk_location () {
    local file=$1

    # TODO
}

# Builds a Docker image and publishes the results to Etcd
#  args: NAME - the name of the image to build;
#        REPO_URL - the Git repository URL of the image to build;
#        TMP_DIR - the temporary directory to use for building the image.
build_image () {
    local name=$1
    local repo_url=$2
    local tmp_dir="${3:-$builder_root}/$(_urlencode $name)"

    docker_img_id=$(docker/get_image_id $name)
    etcd_img_id=$(_get_build_image_id $etcd_ns $name)

    # Ensure we've got a place to store information about this build...
    etcd/mkdir $etcd_ns $img_name

    local old_pwd=$PWD
    if [ -d $tmp_dir ]; then
        # Repository already exists, update it...
        cd $tmp_dir
        git remote update >/dev/null 2>&1
        remote_rev=$(_get_git_rev "origin")
        local_rev=$(_get_git_rev "master")
        if [ "$remote_rev" != "$local_rev" ]; then
            _log "Pulling latest changes for $name in $tmp_dir..."
            git pull origin master >/dev/null 2>&1
        else
            _log "Repository exist, but has no pending changes for $name in $tmp_dir..."
        fi
    else
        _log "Cloning $name to $tmp_dir..."
        # Repository does not exist, clone it...
        git clone --depth=1 $repo_url $tmp_dir >/dev/null 2>&1
        # Determine the current revision...
        cd $tmp_dir
        remote_rev=$(_get_git_rev "origin")
    fi
    cd $old_pwd

    # Some additional sanity checks...
    if [ $? -ne 0 ]; then
        _log "Cloning/updating Git repository failed [$?]..."
        exit $EREPO_CLONE_FAILED
    fi
    if [ ! -f "$tmp_dir/Dockerfile" ]; then
        _log "No Dockerfile found, cannot build image!"
        exit $ENO_DOCKER_REPO
    fi

    # Fetch the last Git rev from Etcd, might another builder instance already be building it?
    local etcd_git_rev=$(etcd/value "$etcd_ns/$name/gitRev")

    if [ "$remote_rev" != "$etcd_git_rev" ] || [ "$docker_img_id" != "$etcd_img_id" ]; then
        _log "Image ($name) not yet build or out of date, starting build..."

        # Build it!
        etcd/put "$etcd_ns/$name/gitRev" $remote_rev
        etcd/put "$etcd_ns/$name/gitRepo" $repo_url

        # Replace the "macros" in the Dockerfile...
        _replace_apt_cacher "$tmp_dir/Dockerfile"
        _replace_jdk_location "$tmp_dir/Dockerfile"

        _log "Building image $name, this can take a little while..."

        docker build -q -t $name $tmp_dir >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            _log "Building image ($name) failed!"
            exit $EBUILD_FAILURE
        fi
        # Fetch the *full* image ID for this image
        local img_id=$(docker/get_image_id $name)

        etcd/put "$etcd_ns/$name/dockerId" "$img_id"

        # Tag & publish the image to all repositories...
        docker/tag $img_id $name "$docker_repos"
        docker/push_image $name "$docker_repos"

        _log "Image ($name) build successfully with ID ${img_id:0:12}!"

        # Returns the image ID
        echo $img_id
    else
        # Make sure to push the latest image to all repositories, let Docker figure
        # out whether it needs to update stuff or not...
        docker/tag $docker_img_id $name "$docker_repos"
        docker/push_image $name "$docker_repos"

        _log "Image ($name) already build or is currently build by another service..."
    fi
}

###
### MAIN
###

# Initialize the Etcd namespace...
etcd/init $etcd_ns

case $command in
    build)
        build_image $img_name $git_repo_url
    ;;
    update)
        images=$(_get_build_image_names $etcd_ns)
        for image in ${images[@]}; do
            gitUrl=$(etcd/value "$image/gitRepo")
            _log "Updating $image from $gitUrl..."
            build_image ${image/$etcd_ns\//} $gitUrl
        done
    ;;
    list)
        _list_build_images $etcd_ns
    ;;
esac

exit 0
