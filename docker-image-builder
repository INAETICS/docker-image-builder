#!/bin/bash
# Facade script for working with Git-based Docker repositories.
#
# (C) 2014 INAETICS, <www.inaetics.org> - Apache License v2.

#FIXME configuration/environment
#FIXME add a forced build
#FIXME better input/error checking
readonly BUILDER_ROOTDIR="/tmp/image-builder"
readonly BUILDER_DEBUG="true"
readonly REGISTRY_NAMESPACE="/inaetics/image-builder-registry"

#
# Util functions 
#

# Wraps a function call to redirect or filter stdout/stderr
# depending on the debug setting
#   args: $@ - the wrapped call
#   return: the wrapped call's return
_call () {
  if [ "$BUILDER_DEBUG" != "true"  ]; then
    $@ &> /dev/null
    return $?
  else
    $@ 2>&1 | awk '{print "[DEBUG] "$0}' >&2
    return ${PIPESTATUS[0]}
  fi
}

# Echo a debug message to stderr, perpending each line
# with a debug prefix.
#   args: $@ - the echo args
_dbg() {
  if [ "$BUILDER_DEBUG" == "true" ]; then
    echo $@ | awk '{print "[DEBUG] "$0}' >&2
  fi
}

# Echo a log message to stderr, perpending each line
# with a info prefix.
#   args: $@ - the echo args
_log() {
  echo $@ | awk '{print "[INFO] "$0}' >&2
}

# Translate an image name [<user>/]<repository>
# into a one that can be used as an (etcd) dir.
#   args: $@ - the name(s)
_dirname () {
  echo "$@" | tr '/' '_'
}

#
# Supporting libs
#

source "$(dirname $0)/lib/builder.sh"
source "$(dirname $0)/lib/docker.sh"
source "$(dirname $0)/lib/etcdctl.sh"

#
# Core functions
#

# Determine the repository directory to use for a specific 
# image name; [<user>/]<repository>
#  args: $1, <name>
#  echo: <dir>
_get_repository_dir () {
  #FIXME check input
  _dbg "-> $FUNCNAME - args: $@"
  if [ ! -d "${BUILDER_ROOTDIR}/repos" ]; then
    _call mkdir ${BUILDER_ROOTDIR}/repos
  fi
  local dir=${BUILDER_ROOTDIR}/repos/$(_dirname $1)
  _dbg "-> $FUNCNAME - dir: $dir"
  echo $dir
}

# Update a git repository by either cloning or pulling and returning
# its master revision
#  args: $1, <repository url>
#   $2, <repository dir>
#  echo: <revision>
_update_git_repository () {
  #FIXME check input
  #git remote -v | grep origin | awk '{print $2}'
  _dbg "-> $FUNCNAME - args: $@"
  if [ -d "$2" ]; then
    _dbg "-> $FUNCNAME - dir exists, pulling!"
    cd $2
    _call git pull
  else
    _dbg "-> $FUNCNAME - dir empty, cloning!"
    _call git clone --depth=1 $1 $2
  fi
  local rev=$(git log --pretty=oneline -1 $branch | awk '{print $1}')
  _dbg "$FUNCNAME - rev: $rev"
  echo $rev
}

# Provides a list of all images that were build.
#   returns: <img name> <git URL> <docker ID>
_list_registry_images () {
  _dbg "-> $FUNCNAME - args: $@"
  local value
  for image in $(etcd/keys $REGISTRY_NAMESPACE); do
    value=$(etcd/value $image)
    _dbg "-> $FUNCNAME - image: $value"
   echo $value
  done
}

_update_registry_images () {
  _dbg "-> $FUNCNAME - args: $@"
  local value; local array
  for image in $(etcd/keys $REGISTRY_NAMESPACE); do
    value=$(etcd/value $image)
    _dbg "-> $FUNCNAME - image: $value"
    array=($value)
    build_image ${array[0]} ${array[3]}
  done
}

# Locate an image in the registry by name and matching repository
# revision.
#  args: $1: <repository name>, format [<user>/]<repository>
#    $2: <repository revision>
#  echo: <dockerid>
#  return: 0, if image was found
#    1, if image was not found
_locate_registry_image () {
  _dbg "-> $FUNCNAME - args: $@"
  local path="$REGISTRY_NAMESPACE/$(_dirname $1)"
  _dbg "-> $FUNCNAME - path: $path"
  local info=$(etcd/value $path)
  _dbg "-> $FUNCNAME - info: $info"
  if [ "${info}" == "" ]; then
    _dbg "-> $FUNCNAME - image not found"
  fi
  local array=(${info//#/ })
  if [ "${array[2]}" != "$2" ]; then  
    _dbg "-> $FUNCNAME - image is old: ${array[2]} != $2"
    return 1
  fi
  _dbg "-> $FUNCNAME - dockerid: ${array[1]}"
  echo ${array[1]}
}

# Locate an image in the registry by name and matching repository
# revision.
#  args: $1: <repository name>, format [<user>/]<repository>
#    $2..n: <image info> 
_publish_registry_image () {
  _dbg "-> $FUNCNAME - args: $@"
  local path="$REGISTRY_NAMESPACE/$(_dirname $1)"
  _dbg "-> $FUNCNAME - path: $path"
  local info=${@:2}
  info=${info// /#}
  _dbg "-> $FUNCNAME - info: $info"
  etcd/put $path "$info"
}

# Push an image to available docker registries.
#  args: $1: <image id>>
#    $2: <image name> 
_push_image_upstream () {
  #FIXME if the image was pulled skip tagging pushing to origin
  _dbg "-> $FUNCNAME - args: $@"
  local registries=$(etcd/values /inaetics/docker-registry-service)
  _dbg "-> $FUNCNAME - registries: $registries"
  local res
  for registry in $registries; do
    res=$(docker/push_image $1 $2 $registry)
    if [ ! "$res" == "" ]; then
      _log "-> pushed $res"
    fi
  done
}

# Push an image to available docker registries.
#  args: $1: <image id>>
#    $2: <image name> 
_pull_image_upstream() {
  _dbg "-> $FUNCNAME - args: $@"
  local registries=$(etcd/values /inaetics/docker-registry-service)
  _dbg "-> $FUNCNAME - registries: $registries"
  for registry in $registries; do
    located_image_name=$(docker/pull_image $1 $2 $registry)
    #FIXME consider imageid during pull so we know we did not pull an  old copy
    located_image_name=$(docker/get_image_name $1)
    if [ "$located_image_name" != "" ]; then
      echo $located_image_name
      return 0
    fi
  done
  return 1
}

# Builds a Docker image and publishes the results to Etcd
#  args: $1: <repository name>, format [<user>/]<repository>
#    $2 - <repository url>
#FIXME rename to locate_image (?)
locate_image () {
  _dbg "-> $FUNCNAME - args: $@"
  local requested_image_name=$1
  local repository_url=$2
  local repository_dir=$(_get_repository_dir $requested_image_name)
  local apt_cachers=($(etcd/values /inaetics/apt-cacher-service))
  local docker_registries=$(etcd/values /inaetics/docker-registry-service)

  _log "Locating image $requested_image_name"
  _dbg "-> $FUNCNAME - url:  $repository_url"
  _dbg "-> $FUNCNAME - dir:  $repository_dir"

  _log "Updating repository from  $repository_url"
  local repository_rev=$(_update_git_repository $repository_url $repository_dir)
  _log "-> repository revision is $repository_rev"

  _log "Looking up image in registry"
  local located_image_id=$(_locate_registry_image $requested_image_name $repository_rev)
  if [ "$located_image_id" == "" ]; then
    _log "-> no image found"
  else
    _log "-> found image: $located_image_id"
  fi

  local located_image_name
  if [ "$located_image_id" != "" ]; then
    _log "Checking for locally stored image"
    located_image_name=$(docker/get_image_name $located_image_id)
    if [ "$located_image_name" != "" ]; then
      _log "-> found local image: $located_image_name"
    else 
      _log "-> no local image found"
    fi
  fi
   
  if [ "$located_image_id" != "" ] && [ "$located_image_name" == "" ]; then
    _log "Checking for remotely available image"
    located_image_name=$(_pull_image_upstream $located_image_id $requested_image_name)
    if [ "$located_image_name" != "" ]; then
      _log "-> pulled remote image: $located_image_name"
    else
      _log "-> no remote image found"
    fi
  fi 

  if [ "$located_image_name" != "" ]; then
    _log "Tagging located image name: $requested_image_name"
    located_image_name=$(docker/tag_image $located_image_id $requested_image_name)
  fi

  if [ "$located_image_name" == "" ]; then
    _log "Building image locally"
    builder/build_image $requested_image_name $repository_dir ${apt_cachers[0]}
    located_image_name=$requested_image_name
    located_image_id=$(docker/get_image_id $located_image_name)
  fi

  _log "Pushing image to docker registries"
  _push_image_upstream $located_image_id $located_image_name

  _log "Publishing image in builder registry"
  _publish_registry_image $requested_image_name $requested_image_name $located_image_id $repository_rev $repository_url
  echo $located_image_id
}

# Print the usage information for this script
_usage() {
  echo "Usage: $(basename $0) COMMAND [arg...]

Commands:
  locate REPO_NAME GIT_REPO_URL
   builds a new or updates an existing Docker image, pulling the repository from
   the given Git repository URL and tagging it with the given REPO_NAME;
  list
   shows a list of all build images.
  update
   checks all previously build images and rebuild them if necessary.
"
}

#
# Main
#

case $1 in
  locate)
    if [ -z $2 ] || [ -z $3 ]; then
      _usage
      exit 1
    fi
    locate_image $2 $3
    exit $?
  ;;
  update)
    _update_registry_images
    exit $?
  ;;
  list)
    printf "%-25s %-12s %-12s %s\n" "REPOSITORY NAME" "IMAGE ID" "GIT REV" "GIT URL"
    _list_registry_images
    exit $?
  ;;
  *)
    _usage
    exit 1
  ;;
esac
